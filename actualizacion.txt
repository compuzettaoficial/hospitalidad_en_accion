# ğŸ  ESTRUCTURA COMPLETA - WEBAPP HOSPITALIDAD CRISTIANA

## ğŸ¯ PROPÃ“SITO Y VALORES FUNDAMENTALES

**MisiÃ³n**: Webapp que conecta cristianos para ofrecer hospitalidad gratuita durante eventos religiosos. Los hermanos sin recursos pueden encontrar hospedaje gratuito en casas de otros cristianos.

**Valores Cristianos Fundamentales**:
- â­ **LA VALORACIÃ“N ES POR COMPORTAMIENTO CRISTIANO, NO POR LUJOS**
- ğŸ  Pueden participar personas humildes con casas humildes
- â¤ï¸ El trato y semejanza al carÃ¡cter de Cristo es lo que se valora
- ğŸ†“ Servicio completamente gratuito
- ğŸ¤ Fomentar la hospitalidad bÃ­blica entre hermanos

---

## ğŸ—ï¸ ESTRUCTURA DE ARCHIVOS ACTUALIZADA

```
/
â”œâ”€â”€ index.html                     â†’ PÃ¡gina principal (grilla eventos)
â”œâ”€â”€ welcome.html                   â†’ PresentaciÃ³n inicial
â”œâ”€â”€ event-detail.html             â†’ Detalle de evento
â”œâ”€â”€ profile.html                   â†’ Mi Perfil (centro de notificaciones)
â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ login.html                 â†’ Login
â”‚   â”œâ”€â”€ register.html              â†’ Registro de usuario
â”‚   â””â”€â”€ forgot-password.html       â†’ Recuperar contraseÃ±a
â”œâ”€â”€ admin/
â”‚   â”œâ”€â”€ dashboard.html             â†’ Panel administrador
â”‚   â”œâ”€â”€ events-management.html     â†’ GestiÃ³n de eventos
â”‚   â”œâ”€â”€ users-management.html      â†’ GestiÃ³n de usuarios
â”‚   â”œâ”€â”€ editors-assignment.html    â†’ AsignaciÃ³n editores a eventos
â”‚   â”œâ”€â”€ verification-center.html   â†’ Centro de verificaciÃ³n manual
â”‚   â”œâ”€â”€ matching-manual.html       â†’ Sistema de emparejamiento manual
â”‚   â”œâ”€â”€ ratings-management.html    â†’ GestiÃ³n de valoraciones
â”‚   â”œâ”€â”€ event-observations.html    â†’ Observaciones por evento
â”‚   â”œâ”€â”€ backup-management.html     â†’ GestiÃ³n de contingencias
â”‚   â”œâ”€â”€ penalties-management.html  â†’ GestiÃ³n de penalizaciones
â”‚   â””â”€â”€ reports.html               â†’ Reportes y estadÃ­sticas
â”œâ”€â”€ editor/
â”‚   â”œâ”€â”€ dashboard.html             â†’ Panel editor (eventos asignados)
â”‚   â”œâ”€â”€ my-events.html             â†’ Mis eventos asignados
â”‚   â”œâ”€â”€ verification-assigned.html â†’ VerificaciÃ³n eventos asignados
â”‚   â”œâ”€â”€ matching-assigned.html     â†’ Emparejamiento eventos asignados
â”‚   â”œâ”€â”€ observations-assigned.html â†’ Observaciones eventos asignados
â”‚   â””â”€â”€ reports-assigned.html      â†’ Reportes de eventos asignados
â”œâ”€â”€ event/
â”‚   â”œâ”€â”€ create-event.html          â†’ Crear evento (admin)
â”‚   â”œâ”€â”€ edit-event.html            â†’ Editar evento (admin/editor asignado)
â”‚   â”œâ”€â”€ hotels-management.html     â†’ GestiÃ³n hoteles/cocheras
â”‚   â”œâ”€â”€ participants.html          â†’ GestiÃ³n participantes
â”‚   â”œâ”€â”€ accommodation-info.html    â†’ Info de alojamientos para asistentes
â”‚   â””â”€â”€ contingency-plan.html      â†’ Plan de contingencia
â”œâ”€â”€ forms/
â”‚   â”œâ”€â”€ host-registration.html     â†’ Registro anfitriÃ³n
â”‚   â”œâ”€â”€ visitor-application.html   â†’ PostulaciÃ³n visitante
â”‚   â”œâ”€â”€ attendee-registration.html â†’ Registro asistente
â”‚   â”œâ”€â”€ verification-form.html     â†’ Formulario verificaciÃ³n
â”‚   â””â”€â”€ application-review.html    â†’ RevisiÃ³n de postulaciones
â”œâ”€â”€ ratings/
â”‚   â”œâ”€â”€ rate-host.html             â†’ Valorar anfitriÃ³n (comportamiento cristiano)
â”‚   â”œâ”€â”€ rate-visitor.html          â†’ Valorar visitante (comportamiento cristiano)
â”‚   â”œâ”€â”€ ratings-display.html       â†’ Mostrar valoraciones
â”‚   â””â”€â”€ christian-criteria.html    â†’ Criterios de valoraciÃ³n cristiana
â”œâ”€â”€ verification/
â”‚   â”œâ”€â”€ pending-verification.html  â†’ Verificaciones pendientes
â”‚   â”œâ”€â”€ verification-process.html  â†’ Proceso de verificaciÃ³n
â”‚   â””â”€â”€ verification-history.html  â†’ Historial de verificaciones
â”œâ”€â”€ notifications/
â”‚   â”œâ”€â”€ profile-notifications.html â†’ Notificaciones en perfil
â”‚   â”œâ”€â”€ status-updates.html        â†’ Actualizaciones de estado
â”‚   â””â”€â”€ reminders.html             â†’ Sistema de recordatorios
â”œâ”€â”€ css/
â”‚   â”œâ”€â”€ main.css                   â†’ Estilos principales
â”‚   â”œâ”€â”€ admin.css                  â†’ Estilos panel admin
â”‚   â”œâ”€â”€ editor.css                 â†’ Estilos panel editor
â”‚   â”œâ”€â”€ forms.css                  â†’ Estilos formularios
â”‚   â”œâ”€â”€ ratings.css                â†’ Estilos sistema valoraciÃ³n
â”‚   â”œâ”€â”€ verification.css           â†’ Estilos verificaciÃ³n
â”‚   â”œâ”€â”€ notifications.css          â†’ Estilos notificaciones
â”‚   â”œâ”€â”€ penalties.css              â†’ Estilos sistema penalizaciones
â”‚   â””â”€â”€ components.css             â†’ Estilos componentes
â”œâ”€â”€ js/
â”‚   â”œâ”€â”€ main.js                    â†’ LÃ³gica principal
â”‚   â”œâ”€â”€ firebase-config.js         â†’ ConfiguraciÃ³n Firebase (ACTUALIZADO)
â”‚   â”œâ”€â”€ auth.js                    â†’ AutenticaciÃ³n
â”‚   â”œâ”€â”€ events.js                  â†’ GestiÃ³n eventos (ACTUALIZADO)
â”‚   â”œâ”€â”€ users.js                   â†’ GestiÃ³n usuarios
â”‚   â”œâ”€â”€ permissions.js             â†’ Control de permisos por evento
â”‚   â”œâ”€â”€ verification.js            â†’ Sistema verificaciÃ³n manual
â”‚   â”œâ”€â”€ matching-manual.js         â†’ Sistema emparejamiento manual
â”‚   â”œâ”€â”€ ratings-christian.js       â†’ Sistema valoraciones cristianas
â”‚   â”œâ”€â”€ notifications.js           â†’ Sistema notificaciones internas (ACTUALIZADO)
â”‚   â”œâ”€â”€ reminders.js               â†’ Sistema de recordatorios automÃ¡ticos
â”‚   â”œâ”€â”€ penalties.js               â†’ Sistema de penalizaciones
â”‚   â”œâ”€â”€ backup-system.js           â†’ Sistema de contingencia
â”‚   â”œâ”€â”€ observations.js            â†’ Sistema de observaciones
â”‚   â””â”€â”€ utils.js                   â†’ Funciones utilitarias
â”œâ”€â”€ img/
â”‚   â”œâ”€â”€ logos/
â”‚   â”œâ”€â”€ banners/
â”‚   â”œâ”€â”€ events/
â”‚   â”œâ”€â”€ hotels/
â”‚   â”œâ”€â”€ christian-values/
â”‚   â””â”€â”€ icons/
â””â”€â”€ components/
    â”œâ”€â”€ header.html
    â”œâ”€â”€ footer.html
    â”œâ”€â”€ event-card.html
    â”œâ”€â”€ star-rating-christian.html
    â”œâ”€â”€ verification-badge.html
    â”œâ”€â”€ notification-center.html
    â”œâ”€â”€ reminder-card.html
    â””â”€â”€ navigation.html
```

---

## ğŸ­ SISTEMA DE ROLES Y PERMISOS ACTUALIZADO

### ğŸ”‘ ADMINISTRADOR (compuzettaoficial@gmail.com)
- âœ… Acceso total a todos los eventos
- âœ… Asignar editores a eventos especÃ­ficos
- âœ… Crear/eliminar eventos en cualquier ciudad
- âœ… Gestionar usuarios y cambiar roles
- âœ… **Sistema de verificaciÃ³n manual completo**
- âœ… **Sistema de emparejamiento manual**
- âœ… **GestiÃ³n de observaciones por evento**
- âœ… **Sistema de backup y contingencias**
- âœ… **GestiÃ³n de penalizaciones y suspensiones**
- âœ… **Control total del sistema de recordatorios**
- âœ… Acceso completo al sistema de valoraciones cristianas
- âœ… Ver reportes globales de toda la plataforma

### âœï¸ EDITOR
- âœ… Acceso limitado solo a eventos asignados por el admin
- âœ… VerificaciÃ³n manual solo de sus eventos asignados
- âœ… Emparejamiento manual solo en sus eventos asignados
- âœ… Editar informaciÃ³n solo de sus eventos asignados
- âœ… Gestionar hoteles/cocheras solo de sus eventos
- âœ… Crear observaciones solo de sus eventos asignados
- âœ… **Aplicar penalizaciones menores en sus eventos**
- âœ… **Gestionar recordatorios de verificaciÃ³n**
- âœ… Ver reportes solo de sus eventos
- âŒ No puede crear eventos nuevos
- âŒ No puede acceder a eventos no asignados

### ğŸ‘¤ USUARIO
- âœ… Acceso bÃ¡sico a funcionalidades
- âœ… Participar en cualquier evento
- âœ… Ver informaciÃ³n de todos los eventos
- âœ… **Centro de notificaciones en Mi Perfil**
- âœ… **Recibir recordatorios de verificaciÃ³n**
- âœ… **Ver historial de penalizaciones**
- âœ… **Sistema de valoraciÃ³n bidireccional**
- âœ… **Proceso de verificaciÃ³n personal**

---

## ğŸ“Š ESTRUCTURA DE BASE DE DATOS ACTUALIZADA

### ğŸ—‚ï¸ ColecciÃ³n: usuarios (ACTUALIZADA CON PENALIZACIONES Y RECORDATORIOS)
```javascript
{
  uid: "user_id",
  nombre: "string",
  apellido: "string",
  email: "string",
  rol: "administrador|editor|usuario",
  telefono: "string",
  estado: "activo|suspendido|penalizado",
  
  // SISTEMA DE PENALIZACIONES (NUEVO)
  penalizaciones: {
    activa: "boolean",
    tipo: "advertencia|suspension_temporal|suspension_permanente",
    fecha_inicio: "timestamp",
    fecha_fin: "timestamp", // null si es permanente
    motivo: "string",
    descripcion: "string",
    aplicada_por: "admin_user_id",
    eventos_afectados: ["evento_id1", "evento_id2"],
    historial: [{
      fecha: "timestamp",
      tipo: "advertencia|suspension_temporal|suspension_permanente",
      motivo: "string",
      aplicada_por: "admin_user_id",
      resuelto: "boolean",
      fecha_resolucion: "timestamp"
    }]
  },
  
  // SISTEMA DE RECORDATORIOS DE VERIFICACIÃ“N (NUEVO)
  recordatorios_verificacion: {
    activos: "boolean",
    ultimo_recordatorio: "timestamp",
    recordatorios_enviados: "number",
    metodo_preferido: "notificacion_interna|whatsapp|email",
    frecuencia: "diaria|cada_3_dias|semanal",
    eventos_pendientes: ["evento_id1", "evento_id2"],
    historial_recordatorios: [{
      fecha_enviado: "timestamp",
      tipo: "verificacion_pendiente|documento_faltante|cancelacion_evento",
      evento_id: "string",
      metodo: "notificacion_interna|whatsapp|email",
      estado: "enviado|entregado|leido|respondido"
    }]
  },
  
  // SISTEMA DE VERIFICACIÃ“N MANUAL
  verificacion: {
    estado: "pendiente_verificacion|verificado|rechazado",
    fecha_solicitud: "timestamp",
    fecha_verificacion: "timestamp",
    verificado_por: "admin_user_id",
    notas_verificador: "string",
    metodo_verificacion: "whatsapp|llamada|presencial",
    contacto_verificacion: "string",
    documentos_verificados: ["cedula", "referencias", "etc"],
    intentos_verificacion: "number",
    recordatorios_enviados: "number"
  },
  
  // SISTEMA DE VALORACIÃ“N CRISTIANA
  valoracion: {
    base_registro: 1, // +1 estrella por registrarse
    base_verificacion: 1, // +1 estrella por verificaciÃ³n
    penalizacion_activa: -1, // -1 estrella si tiene penalizaciÃ³n activa
    valoraciones_recibidas: [{
      evento_id: "string",
      valorador_id: "string",
      puntos: "number (1-5)",
      comentario: "string",
      criterios_cristianos: {
        amabilidad: "number (1-5)",
        hospitalidad: "number (1-5)", 
        respeto: "number (1-5)",
        caracter_cristiano: "number (1-5)",
        servicio_desinteresado: "number (1-5)"
      },
      fecha_valoracion: "timestamp"
    }],
    promedio_total: "number",
    total_valoraciones: "number"
  },
  
  // NOTIFICACIONES INTERNAS (SIN COSTO)
  notificaciones_internas: {
    verificacion_estado: "pendiente|completada|rechazada",
    postulaciones: [{
      evento_id: "string",
      tipo: "hospedador|visitante",
      estado: "postulado|verificado|asignado|rechazado",
      fecha_postulacion: "timestamp",
      fecha_actualizacion: "timestamp"
    }],
    asignaciones_actuales: [{
      evento_id: "string",
      tipo: "hospedador|visitante",
      asignado_con: "user_id",
      fecha_asignacion: "timestamp"
    }],
    mensajes_admin: [{
      mensaje: "string",
      fecha: "timestamp",
      leido: "boolean"
    }],
    recordatorios_pendientes: [{
      tipo: "verificacion|documentos|cancelacion",
      evento_id: "string",
      fecha_programada: "timestamp",
      procesado: "boolean"
    }]
  },
  
  // SISTEMA DE EDITORES
  eventos_asignados: ["evento_id1", "evento_id2"], // Solo para editores
  asignado_por: "admin_user_id",
  fecha_asignacion: "timestamp",
  createdAt: "timestamp"
}
```

### ğŸ—‚ï¸ ColecciÃ³n: postulaciones (ACTUALIZADA CON CANCELACIONES)
```javascript
{
  id: "postulacion_id",
  evento_id: "string",
  usuario_id: "string",
  tipo: "hospedador|visitante",
  
  // ESTADOS DETALLADOS
  estado: "postulado|verificado|asignado|rechazado|cancelado",
  fecha_postulacion: "timestamp",
  fecha_verificacion: "timestamp",
  fecha_asignacion: "timestamp",
  fecha_cancelacion: "timestamp",
  
  // SISTEMA DE CANCELACIÃ“N (NUEVO)
  cancelacion: {
    cancelado_por: "usuario|admin|sistema",
    fecha_cancelacion: "timestamp",
    motivo: "string",
    motivo_categoria: "personal|enfermedad|emergencia|penalizacion|no_verificado",
    afecta_valoracion: "boolean",
    penalizacion_aplicada: "boolean",
    usuario_cancelador: "user_id",
    admin_cancelador: "admin_user_id",
    notificaciones_enviadas: "boolean",
    backup_activado: "boolean"
  },
  
  // VERIFICACIÃ“N MANUAL
  verificacion_admin: {
    verificado_por: "admin_user_id",
    fecha_verificacion: "timestamp",
    metodo_verificacion: "whatsapp|llamada|presencial",
    notas_verificacion: "string",
    documentos_revisados: ["string"],
    aprobado: "boolean",
    recordatorios_enviados: "number"
  },
  
  // DATOS HOSPEDADOR
  datos_hospedador: {
    numero_habitaciones: "number",
    numero_camas: "number",
    personas_puede_hospedar: "number",
    tiene_cochera: "boolean",
    servicios_adicionales: ["desayuno", "transporte", "etc"],
    reglas_casa: "string",
    ubicacion_detalle: "string"
  },
  
  // DATOS VISITANTE
  datos_visitante: {
    numero_personas: "number",
    habitaciones_solicitadas: "number",
    tiene_vehiculo: "boolean",
    necesidades_especiales: "string",
    preferencias: "string",
    referencias: "string"
  },
  
  // ASIGNACIÃ“N MANUAL
  asignacion: {
    asignado_con: "user_id",
    asignado_por: "admin_user_id",
    fecha_asignacion: "timestamp",
    notas_asignacion: "string",
    es_asignacion_backup: "boolean"
  }
}
```

### ğŸ—‚ï¸ ColecciÃ³n: recordatorios_sistema (NUEVA)
```javascript
{
  id: "recordatorio_id",
  usuario_id: "string",
  evento_id: "string",
  tipo: "verificacion_pendiente|documento_faltante|cancelacion_evento|evento_proximo",
  
  // CONFIGURACIÃ“N DEL RECORDATORIO
  activo: "boolean",
  fecha_programada: "timestamp",
  fecha_enviado: "timestamp",
  procesado: "boolean",
  metodo_envio: "notificacion_interna|whatsapp|email",
  
  // CONTENIDO DEL RECORDATORIO
  titulo: "string",
  mensaje: "string",
  accion_requerida: "string",
  enlace_accion: "string",
  
  // REPETICIÃ“N
  es_recurrente: "boolean",
  frecuencia: "diaria|cada_3_dias|semanal",
  max_recordatorios: "number",
  recordatorios_enviados: "number",
  
  // SEGUIMIENTO
  estado_respuesta: "pendiente|respondido|ignorado|completado",
  fecha_respuesta: "timestamp",
  respuesta_usuario: "string",
  
  // METADATA
  creado_por: "sistema|admin_user_id",
  fecha_creacion: "timestamp",
  prioridad: "baja|media|alta|urgente"
}
```

### ğŸ—‚ï¸ ColecciÃ³n: penalizaciones (NUEVA)
```javascript
{
  id: "penalizacion_id",
  usuario_id: "string",
  evento_id: "string",
  
  // TIPO DE PENALIZACIÃ“N
  tipo: "advertencia|suspension_temporal|suspension_permanente",
  gravedad: "leve|moderada|grave|muy_grave",
  
  // MOTIVO Y DESCRIPCIÃ“N
  motivo_categoria: "cancelacion_tardÃ­a|no_verificacion|comportamiento_inadecuado|valoracion_negativa|incumplimiento_reglas",
  motivo_detalle: "string",
  descripcion_completa: "string",
  evidencia: ["string"], // URLs de capturas, documentos, etc.
  
  // APLICACIÃ“N
  aplicada_por: "admin_user_id",
  fecha_aplicacion: "timestamp",
  fecha_inicio: "timestamp",
  fecha_fin: "timestamp", // null si es permanente
  
  // ESTADO
  estado: "activa|cumplida|revocada|apelada",
  fecha_cumplimiento: "timestamp",
  fecha_revocacion: "timestamp",
  
  // RESTRICCIONES
  restricciones: {
    postular_eventos: "boolean",
    ser_anfitrion: "boolean",
    ser_visitante: "boolean",
    eventos_especÃ­ficos: ["evento_id1", "evento_id2"],
    todas_las_ciudades: "boolean"
  },
  
  // APELACIÃ“N
  apelacion: {
    presentada: "boolean",
    fecha_apelacion: "timestamp",
    motivo_apelacion: "string",
    documentos_apelacion: ["string"],
    revisada_por: "admin_user_id",
    fecha_revision: "timestamp",
    resultado: "aprobada|rechazada|pendiente",
    comentarios_revision: "string"
  },
  
  // SEGUIMIENTO
  notificaciones_enviadas: "boolean",
  usuario_notificado: "timestamp",
  impacto_valoracion: "boolean"
}
```

---

## ğŸ”„ FLUJOS DE TRABAJO ACTUALIZADOS

### 1. ğŸ“‹ FLUJO DE RECORDATORIOS DE VERIFICACIÃ“N
```
Usuario se registra â†’ Estado: "pendiente_verificacion"
     â†“
Sistema programa recordatorio automÃ¡tico (+24h)
     â†“
Si no se verifica â†’ Recordatorio cada 3 dÃ­as (mÃ¡ximo 3)
     â†“
Si no responde â†’ Admin recibe notificaciÃ³n para intervenciÃ³n manual
     â†“
Admin decide: verificar manualmente o penalizar
```

### 2. âš ï¸ FLUJO DE PENALIZACIONES
```
Incidente ocurre (cancelaciÃ³n tardÃ­a, mal comportamiento, etc.)
     â†“
Admin/Editor evalÃºa gravedad
     â†“
Aplica penalizaciÃ³n correspondiente
     â†“
Usuario recibe notificaciÃ³n con detalles
     â†“
Usuario puede apelar (7 dÃ­as)
     â†“
Admin revisa apelaciÃ³n â†’ Mantiene o revoca penalizaciÃ³n
```

### 3. ğŸ”„ FLUJO DE CANCELACIONES CON BACKUP
```
Usuario cancela postulaciÃ³n
     â†“
Sistema evalÃºa: Â¿CancelaciÃ³n tardÃ­a? Â¿Afecta a otros?
     â†“
Si es tardÃ­a â†’ Aplica penalizaciÃ³n automÃ¡tica
     â†“
Busca en lista de backup del evento
     â†“
Reasigna automÃ¡ticamente o notifica a admin
     â†“
EnvÃ­a notificaciones a afectados
```

### 4. ğŸ“± FLUJO DE NOTIFICACIONES INTERNAS
```
Evento ocurre (verificaciÃ³n, asignaciÃ³n, cancelaciÃ³n, etc.)
     â†“
Sistema genera notificaciÃ³n interna
     â†“
Se almacena en perfil del usuario
     â†“
Usuario ve notificaciÃ³n en "Mi Perfil"
     â†“
Puede marcar como leÃ­da o tomar acciÃ³n
```

---

## ğŸ› ï¸ FUNCIONES JAVASCRIPT ACTUALIZADAS

### 1. ğŸ“± notifications.js (ACTUALIZADO)
```javascript
// Sistema de notificaciones internas sin costo
class NotificationSystem {
  constructor() {
    this.notifications = [];
    this.initializeNotifications();
  }
  
  // Inicializar sistema de notificaciones
  initializeNotifications() {
    this.loadUserNotifications();
    this.setupNotificationListener();
  }
  
  // Cargar notificaciones del usuario
  async loadUserNotifications() {
    const user = auth.currentUser;
    if (!user) return;
    
    const userDoc = await db.collection('usuarios').doc(user.uid).get();
    const userData = userDoc.data();
    
    this.notifications = userData.notificaciones_internas || {};
    this.displayNotifications();
  }
  
  // Agregar nueva notificaciÃ³n
  async addNotification(userId, type, data) {
    const notification = {
      id: this.generateNotificationId(),
      tipo: type,
      fecha: new Date(),
      leido: false,
      ...data
    };
    
    await db.collection('usuarios').doc(userId).update({
      [`notificaciones_internas.${type}`]: firebase.firestore.FieldValue.arrayUnion(notification)
    });
    
    this.updateNotificationBadge(userId);
  }
  
  // NotificaciÃ³n de verificaciÃ³n
  async notifyVerificationStatus(userId, status, eventId = null) {
    const messages = {
      'pendiente': 'Tu verificaciÃ³n estÃ¡ pendiente. Te contactaremos pronto.',
      'verificado': 'Â¡VerificaciÃ³n completada! Ya puedes postular a eventos.',
      'rechazado': 'Tu verificaciÃ³n fue rechazada. Revisa los motivos.'
    };
    
    await this.addNotification(userId, 'verificacion_estado', {
      mensaje: messages[status],
      estado: status,
      evento_id: eventId,
      requiere_accion: status === 'rechazado'
    });
  }
  
  // NotificaciÃ³n de postulaciÃ³n
  async notifyApplicationStatus(userId, eventId, status, hostId = null) {
    const messages = {
      'postulado': 'Tu postulaciÃ³n ha sido recibida y estÃ¡ en revisiÃ³n.',
      'verificado': 'Tu postulaciÃ³n ha sido verificada exitosamente.',
      'asignado': 'Te hemos asignado hospedaje. Revisa los detalles.',
      'rechazado': 'Tu postulaciÃ³n no fue aceptada esta vez.',
      'cancelado': 'Tu postulaciÃ³n ha sido cancelada.'
    };
    
    await this.addNotification(userId, 'postulaciones', {
      evento_id: eventId,
      mensaje: messages[status],
      estado: status,
      asignado_con: hostId,
      requiere_accion: status === 'asignado'
    });
  }
  
  // NotificaciÃ³n de penalizaciÃ³n
  async notifyPenalty(userId, penaltyType, reason, eventId = null) {
    const messages = {
      'advertencia': 'Has recibido una advertencia. Revisa los detalles.',
      'suspension_temporal': 'Tu cuenta ha sido suspendida temporalmente.',
      'suspension_permanente': 'Tu cuenta ha sido suspendida permanentemente.'
    };
    
    await this.addNotification(userId, 'mensajes_admin', {
      mensaje: messages[penaltyType],
      tipo: 'penalizacion',
      motivo: reason,
      evento_id: eventId,
      requiere_accion: true,
      puede_apelar: penaltyType !== 'advertencia'
    });
  }
  
  // NotificaciÃ³n de recordatorio
  async notifyReminder(userId, reminderType, eventId, message) {
    await this.addNotification(userId, 'recordatorios_pendientes', {
      tipo: reminderType,
      evento_id: eventId,
      mensaje: message,
      fecha_programada: new Date(),
      procesado: false
    });
  }
  
  // Mostrar notificaciones en el perfil
  displayNotifications() {
    const container = document.getElementById('notificationsContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    // VerificaciÃ³n
    if (this.notifications.verificacion_estado) {
      this.renderVerificationNotification();
    }
    
    // Postulaciones
    if (this.notifications.postulaciones) {
      this.renderApplicationNotifications();
    }
    
    // Asignaciones
    if (this.notifications.asignaciones_actuales) {
      this.renderAssignmentNotifications();
    }
    
    // Mensajes admin
    if (this.notifications.mensajes_admin) {
      this.renderAdminMessages();
    }
    
    // Recordatorios
    if (this.notifications.recordatorios_pendientes) {
      this.renderReminders();
    }
  }
  
  // Renderizar notificaciÃ³n de verificaciÃ³n
  renderVerificationNotification() {
    const container = document.getElementById('verificationNotifications');
    const status = this.notifications.verificacion_estado;
    
    const statusConfig = {
      'pendiente': { color: 'warning', icon: 'â³', action: 'Esperando verificaciÃ³n' },
      'completada': { color: 'success', icon: 'âœ…', action: 'VerificaciÃ³n completada' },
      'rechazada': { color: 'danger', icon: 'âŒ', action: 'VerificaciÃ³n rechazada' }
    };
    
    const config = statusConfig[status] || statusConfig['pendiente'];
    
    container.innerHTML = `
      <div class="notification-card ${config.color}">
        <div class="notification-header">
          <span class="notification-icon">${config.icon}</span>
          <h4>Estado de VerificaciÃ³n</h4>
        </div>
        <p>${config.action}</p>
        ${status === 'rechazada' ? '<button class="btn btn-outline" onclick="retryVerification()">Volver a intentar</button>' : ''}
      </div>
    `;
  }
  
  // Renderizar notificaciones de postulaciones
  renderApplicationNotifications() {
    const container = document.getElementById('applicationNotifications');
    const applications = this.notifications.postulaciones || [];
    
    container.innerHTML = applications.map(app => `
      <div class="notification-card">
        <div class="notification-header">
          <span class="notification-icon">${this.getApplicationIcon(app.estado)}</span>
          <h4>PostulaciÃ³n - ${app.evento_id}</h4>
        </div>
        <p>Estado: ${app.estado}</p>
        <small>Ãšltima actualizaciÃ³n: ${new Date(app.fecha_actualizacion).toLocaleDateString()}</small>
        ${app.requiere_accion ? '<button class="btn btn-primary" onclick="viewApplicationDetails(\'' + app.evento_id + '\')">Ver detalles</button>' : ''}
      </div>
    `).join('');
  }
  
  // Renderizar asignaciones actuales
  renderAssignmentNotifications() {
    const container = document.getElementById('assignmentNotifications');
    const assignments = this.notifications.asignaciones_actuales || [];
    
    container.innerHTML = assignments.map(assignment => `
      <div class="notification-card success">
        <div class="notification-header">
          <span class="notification-icon">ğŸ </span>
          <h4>AsignaciÃ³n Activa</h4>
        </div>
        <p>Evento: ${assignment.evento_id}</p>
        <p>Tipo: ${assignment.tipo}</p>
        <p>Asignado con: ${assignment.asignado_con}</p>
        <small>Fecha: ${new Date(assignment.fecha_asignacion).toLocaleDateString()}</small>
        <button class="btn btn-outline" onclick="viewAssignmentDetails('${assignment.evento_id}')">Ver detalles</button>
      </div>
    `).join('');
  }
  
  // Renderizar mensajes administrativos
  renderAdminMessages() {
    const container = document.getElementById('adminMessages');
    const messages = this.notifications.mensajes_admin || [];
    
    container.innerHTML = messages.map(msg => `
      <div class="notification-card ${msg.tipo === 'penalizacion' ? 'danger' : 'info'}">
        <div class="notification-header">
          <span class="notification-icon">${msg.tipo === 'penalizacion' ? 'âš ï¸' : 'ğŸ“¢'}</span>
          <h4>Mensaje Administrativo</h4>
        </div>
        <p>${msg.mensaje}</p>
        ${msg.motivo ? `<p>
++++++++++++++++++++++++++++++++++++++++++++
# ğŸ  CONTINUACIÃ“N DEL AVANCE - WEBAPP HOSPITALIDAD CRISTIANA

## ğŸ“± SISTEMA DE NOTIFICACIONES INTERNAS - CONTINUACIÃ“N

### 3. ğŸ’¬ Renderizar mensajes administrativos
```javascript
// notifications.js - ContinuaciÃ³n
function renderAdminMessages(messages) {
  const container = document.getElementById('adminMessages');
  
  if (!messages || messages.length === 0) {
    container.innerHTML = '<p class="no-messages">No hay mensajes administrativos</p>';
    return;
  }
  
  container.innerHTML = messages.map(msg => `
    <div class="admin-message ${msg.leido ? 'read' : 'unread'}">
      <div class="message-header">
        <span class="message-date">${formatDate(msg.fecha)}</span>
        <span class="message-status">${msg.leido ? 'âœ…' : 'ğŸ””'}</span>
      </div>
      <div class="message-content">
        ${msg.mensaje}
      </div>
      ${!msg.leido ? `<button onclick="markAsRead('${msg.id}')">Marcar como leÃ­do</button>` : ''}
    </div>
  `).join('');
}

// Marcar mensaje como leÃ­do
async function markAsRead(messageId) {
  try {
    const currentUser = getCurrentUser();
    const userRef = doc(db, 'usuarios', currentUser.uid);
    
    await updateDoc(userRef, {
      [`notificaciones_internas.mensajes_admin.${messageId}.leido`]: true
    });
    
    // Recargar mensajes
    loadUserNotifications();
    
  } catch (error) {
    console.error('Error marcando mensaje como leÃ­do:', error);
  }
}
```

### 4. ğŸ”” Sistema de badges de notificaciones
```javascript
// notifications.js - Badges
function updateNotificationBadges() {
  const currentUser = getCurrentUser();
  if (!currentUser) return;
  
  // Contar notificaciones no leÃ­das
  getUserDoc(currentUser.uid).then(userData => {
    if (!userData) return;
    
    const notifications = userData.notificaciones_internas || {};
    let unreadCount = 0;
    
    // Contar mensajes admin no leÃ­dos
    if (notifications.mensajes_admin) {
      unreadCount += notifications.mensajes_admin.filter(msg => !msg.leido).length;
    }
    
    // Contar postulaciones con actualizaciones
    if (notifications.postulaciones) {
      const recentUpdates = notifications.postulaciones.filter(post => 
        isRecentUpdate(post.fecha_actualizacion)
      );
      unreadCount += recentUpdates.length;
    }
    
    // Actualizar badges en UI
    updateBadgeDisplay(unreadCount);
  });
}

function updateBadgeDisplay(count) {
  const badges = document.querySelectorAll('.notification-badge');
  badges.forEach(badge => {
    if (count > 0) {
      badge.textContent = count;
      badge.style.display = 'block';
    } else {
      badge.style.display = 'none';
    }
  });
}

function isRecentUpdate(timestamp) {
  const now = new Date();
  const updateTime = new Date(timestamp);
  const diffHours = (now - updateTime) / (1000 * 60 * 60);
  return diffHours <= 24; // Considerar reciente si fue en las Ãºltimas 24 horas
}
```

---

## ğŸ¯ SISTEMA DE EVENTOS ACTUALIZADO - CONTINUACIÃ“N

### 5. ğŸ“Š GestiÃ³n de estadÃ­sticas en tiempo real
```javascript
// events.js - ContinuaciÃ³n
async function updateEventStats(eventId) {
  try {
    const postulacionesRef = collection(db, 'postulaciones');
    const q = query(postulacionesRef, where('evento_id', '==', eventId));
    const snapshot = await getDocs(q);
    
    const stats = {
      anfitriones: 0,
      visitantes: 0,
      asistentes: 0,
      emparejamientos: 0,
      verificaciones_completadas: 0
    };
    
    snapshot.forEach(doc => {
      const data = doc.data();
      
      if (data.tipo === 'hospedador') {
        stats.anfitriones++;
      } else if (data.tipo === 'visitante') {
        stats.visitantes++;
      }
      
      if (data.estado === 'verificado') {
        stats.verificaciones_completadas++;
      }
      
      if (data.estado === 'asignado') {
        stats.emparejamientos++;
      }
    });
    
    // Contar asistentes (usuarios que solo van al evento, no necesitan hospedaje)
    const asistentesRef = collection(db, 'asistentes');
    const qAsistentes = query(asistentesRef, where('evento_id', '==', eventId));
    const asistentesSnapshot = await getDocs(qAsistentes);
    stats.asistentes = asistentesSnapshot.size;
    
    // Actualizar estadÃ­sticas en el evento
    const eventoRef = doc(db, 'eventos', eventId);
    await updateDoc(eventoRef, {
      estadisticas: stats
    });
    
    return stats;
    
  } catch (error) {
    console.error('Error actualizando estadÃ­sticas:', error);
    throw error;
  }
}

// FunciÃ³n para obtener eventos con filtros mejorados
async function getEventsWithFilters(filters = {}) {
  try {
    let q = collection(db, 'eventos');
    
    // Aplicar filtros
    if (filters.ciudad) {
      q = query(q, where('ciudad', '==', filters.ciudad));
    }
    
    if (filters.fechaDesde) {
      q = query(q, where('fecha_inicio', '>=', filters.fechaDesde));
    }
    
    if (filters.fechaHasta) {
      q = query(q, where('fecha_fin', '<=', filters.fechaHasta));
    }
    
    if (filters.estado) {
      q = query(q, where('estado', '==', filters.estado));
    }
    
    // Ordenar por fecha
    q = query(q, orderBy('fecha_inicio', 'desc'));
    
    const snapshot = await getDocs(q);
    const events = [];
    
    snapshot.forEach(doc => {
      events.push({ id: doc.id, ...doc.data() });
    });
    
    return events;
    
  } catch (error) {
    console.error('Error obteniendo eventos filtrados:', error);
    throw error;
  }
}
```

### 6. ğŸ¨ GestiÃ³n de alojamientos alternativos
```javascript
// events.js - Hoteles y cocheras
async function addHotelToEvent(eventId, hotelData) {
  try {
    const eventoRef = doc(db, 'eventos', eventId);
    const eventoDoc = await getDoc(eventoRef);
    
    if (!eventoDoc.exists()) {
      throw new Error('Evento no encontrado');
    }
    
    const currentData = eventoDoc.data();
    const hoteles = currentData.hoteles || [];
    
    // Agregar nuevo hotel
    const nuevoHotel = {
      id: generateId(),
      nombre: hotelData.nombre,
      direccion: hotelData.direccion,
      telefono: hotelData.telefono,
      precio_aproximado: hotelData.precio_aproximado,
      distancia_evento: hotelData.distancia_evento,
      notas: hotelData.notas || '',
      fecha_agregado: new Date().toISOString()
    };
    
    hoteles.push(nuevoHotel);
    
    await updateDoc(eventoRef, {
      hoteles: hoteles
    });
    
    return nuevoHotel;
    
  } catch (error) {
    console.error('Error agregando hotel:', error);
    throw error;
  }
}

async function addCocheraToEvent(eventId, cocheraData) {
  try {
    const eventoRef = doc(db, 'eventos', eventId);
    const eventoDoc = await getDoc(eventoRef);
    
    if (!eventoDoc.exists()) {
      throw new Error('Evento no encontrado');
    }
    
    const currentData = eventoDoc.data();
    const cocheras = currentData.cocheras || [];
    
    // Agregar nueva cochera
    const nuevaCochera = {
      id: generateId(),
      nombre: cocheraData.nombre,
      direccion: cocheraData.direccion,
      telefono: cocheraData.telefono,
      precio_por_dia: cocheraData.precio_por_dia,
      capacidad: cocheraData.capacidad,
      distancia_evento: cocheraData.distancia_evento,
      notas: cocheraData.notas || '',
      fecha_agregado: new Date().toISOString()
    };
    
    cocheras.push(nuevaCochera);
    
    await updateDoc(eventoRef, {
      cocheras: cocheras
    });
    
    return nuevaCochera;
    
  } catch (error) {
    console.error('Error agregando cochera:', error);
    throw error;
  }
}

// FunciÃ³n para mostrar alojamientos en la UI
function renderAccommodations(hoteles, cocheras) {
  const hotelesContainer = document.getElementById('hotelesList');
  const cocherasContainer = document.getElementById('cocherasList');
  
  // Renderizar hoteles
  if (hoteles && hoteles.length > 0) {
    hotelesContainer.innerHTML = hoteles.map(hotel => `
      <div class="accommodation-card">
        <div class="accommodation-header">
          <h4>${hotel.nombre}</h4>
          <span class="price">${hotel.precio_aproximado}</span>
        </div>
        <div class="accommodation-details">
          <p><strong>ğŸ“ DirecciÃ³n:</strong> ${hotel.direccion}</p>
          <p><strong>ğŸ“ TelÃ©fono:</strong> ${hotel.telefono}</p>
          <p><strong>ğŸš— Distancia:</strong> ${hotel.distancia_evento}</p>
          ${hotel.notas ? `<p><strong>ğŸ“ Notas:</strong> ${hotel.notas}</p>` : ''}
        </div>
        <div class="accommodation-actions">
          <button onclick="callHotel('${hotel.telefono}')">ğŸ“ Llamar</button>
          <button onclick="getDirections('${hotel.direccion}')">ğŸ—ºï¸ CÃ³mo llegar</button>
        </div>
      </div>
    `).join('');
  } else {
    hotelesContainer.innerHTML = '<p class="no-data">No hay hoteles registrados para este evento</p>';
  }
  
  // Renderizar cocheras
  if (cocheras && cocheras.length > 0) {
    cocherasContainer.innerHTML = cocheras.map(cochera => `
      <div class="accommodation-card">
        <div class="accommodation-header">
          <h4>${cochera.nombre}</h4>
          <span class="price">${cochera.precio_por_dia}/dÃ­a</span>
        </div>
        <div class="accommodation-details">
          <p><strong>ğŸ“ DirecciÃ³n:</strong> ${cochera.direccion}</p>
          <p><strong>ğŸ“ TelÃ©fono:</strong> ${cochera.telefono}</p>
          <p><strong>ğŸš— Capacidad:</strong> ${cochera.capacidad} vehÃ­culos</p>
          <p><strong>ğŸš— Distancia:</strong> ${cochera.distancia_evento}</p>
          ${cochera.notas ? `<p><strong>ğŸ“ Notas:</strong> ${cochera.notas}</p>` : ''}
        </div>
        <div class="accommodation-actions">
          <button onclick="callCochera('${cochera.telefono}')">ğŸ“ Llamar</button>
          <button onclick="getDirections('${cochera.direccion}')">ğŸ—ºï¸ CÃ³mo llegar</button>
        </div>
      </div>
    `).join('');
  } else {
    cocherasContainer.innerHTML = '<p class="no-data">No hay cocheras registradas para este evento</p>';
  }
}
```

---

## ğŸ”§ CONFIGURACIÃ“N FIREBASE ACTUALIZADA

### 7. ğŸ”¥ firebase-config.js - ConfiguraciÃ³n completa
```javascript
// firebase-config.js - ConfiguraciÃ³n actualizada
import { initializeApp } from 'firebase/app';
import { getFirestore, connectFirestoreEmulator } from 'firebase/firestore';
import { getAuth, connectAuthEmulator } from 'firebase/auth';
import { getStorage, connectStorageEmulator } from 'firebase/storage';
import { getFunctions, connectFunctionsEmulator } from 'firebase/functions';

// ConfiguraciÃ³n Firebase
const firebaseConfig = {
  apiKey: "tu-api-key",
  authDomain: "tu-proyecto.firebaseapp.com",
  projectId: "tu-proyecto-id",
  storageBucket: "tu-proyecto.appspot.com",
  messagingSenderId: "123456789",
  appId: "tu-app-id"
};

// Inicializar Firebase
const app = initializeApp(firebaseConfig);

// Inicializar servicios
export const db = getFirestore(app);
export const auth = getAuth(app);
export const storage = getStorage(app);
export const functions = getFunctions(app);

// Configurar emuladores en desarrollo
if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
  console.log('ğŸ”§ Conectando a emuladores Firebase...');
  
  connectFirestoreEmulator(db, 'localhost', 8080);
  connectAuthEmulator(auth, 'http://localhost:9099');
  connectStorageEmulator(storage, 'localhost', 9199);
  connectFunctionsEmulator(functions, 'localhost', 5001);
}

// Funciones de utilidad para la base de datos
export const collections = {
  usuarios: 'usuarios',
  eventos: 'eventos',
  postulaciones: 'postulaciones',
  emparejamientos: 'emparejamientos',
  valoraciones_cristianas: 'valoraciones_cristianas',
  observaciones_eventos: 'observaciones_eventos',
  verificaciones_manuales: 'verificaciones_manuales',
  asistentes: 'asistentes'
};

// Configuraciones de la aplicaciÃ³n
export const appConfig = {
  // LÃ­mites de la aplicaciÃ³n
  maxPostulacionesPorEvento: 1, // Un usuario solo puede postular una vez por evento
  maxEmparejamientosPorUsuario: 3, // MÃ¡ximo 3 emparejamientos simultÃ¡neos
  diasLimiteValoracion: 7, // 7 dÃ­as despuÃ©s del evento para valorar
  
  // ConfiguraciÃ³n de verificaciÃ³n
  verificacionRequerida: true,
  metodosVerificacion: ['whatsapp', 'llamada', 'presencial'],
  
  // ConfiguraciÃ³n de notificaciones
  notificacionesHabilitadas: true,
  
  // ConfiguraciÃ³n de roles
  rolesPermitidos: ['administrador', 'editor', 'usuario'],
  
  // Estados de postulaciÃ³n
  estadosPostulacion: ['postulado', 'verificado', 'asignado', 'rechazado', 'cancelado'],
  
  // Criterios de valoraciÃ³n cristiana
  criteriosValoracion: [
    'amabilidad',
    'hospitalidad', 
    'respeto',
    'caracter_cristiano',
    'servicio_desinteresado',
    'paciencia',
    'generosidad'
  ]
};

// FunciÃ³n para obtener configuraciÃ³n por usuario
export function getUserConfig(userRole) {
  const baseConfig = {
    canCreateEvents: false,
    canEditEvents: false,
    canVerifyUsers: false,
    canManageUsers: false,
    canViewReports: false,
    canAssignEditors: false,
    canAccessAllEvents: false
  };
  
  switch (userRole) {
    case 'administrador':
      return {
        ...baseConfig,
        canCreateEvents: true,
        canEditEvents: true,
        canVerifyUsers: true,
        canManageUsers: true,
        canViewReports: true,
        canAssignEditors: true,
        canAccessAllEvents: true
      };
      
    case 'editor':
      return {
        ...baseConfig,
        canEditEvents: true, // Solo eventos asignados
        canVerifyUsers: true, // Solo para eventos asignados
        canViewReports: true // Solo reportes de eventos asignados
      };
      
    case 'usuario':
    default:
      return baseConfig;
  }
}

// FunciÃ³n para inicializar la aplicaciÃ³n
export async function initializeApp() {
  try {
    console.log('ğŸš€ Inicializando aplicaciÃ³n...');
    
    // Verificar conexiÃ³n a Firebase
    await testFirebaseConnection();
    
    // Configurar listeners de autenticaciÃ³n
    setupAuthListeners();
    
    // Configurar listeners de conectividad
    setupConnectivityListeners();
    
    console.log('âœ… AplicaciÃ³n inicializada correctamente');
    
  } catch (error) {
    console.error('âŒ Error inicializando aplicaciÃ³n:', error);
    throw error;
  }
}

// FunciÃ³n para probar conexiÃ³n a Firebase
async function testFirebaseConnection() {
  try {
    // Intentar hacer una consulta simple
    const testDoc = doc(db, 'test', 'connection');
    await getDoc(testDoc);
    console.log('âœ… ConexiÃ³n a Firebase establecida');
  } catch (error) {
    console.error('âŒ Error de conexiÃ³n a Firebase:', error);
    throw error;
  }
}

// Configurar listeners de autenticaciÃ³n
function setupAuthListeners() {
  onAuthStateChanged(auth, (user) => {
    if (user) {
      console.log('ğŸ‘¤ Usuario autenticado:', user.email);
      // Actualizar UI para usuario autenticado
      updateUIForAuthenticatedUser(user);
    } else {
      console.log('ğŸ‘¤ Usuario no autenticado');
      // Actualizar UI para usuario no autenticado
      updateUIForUnauthenticatedUser();
    }
  });
}

// Configurar listeners de conectividad
function setupConnectivityListeners() {
  window.addEventListener('online', () => {
    console.log('ğŸŒ ConexiÃ³n restaurada');
    showNotification('ConexiÃ³n restaurada', 'success');
  });
  
  window.addEventListener('offline', () => {
    console.log('ğŸŒ ConexiÃ³n perdida');
    showNotification('ConexiÃ³n perdida. Trabajando en modo offline.', 'warning');
  });
}

// FunciÃ³n para mostrar notificaciones
function showNotification(message, type = 'info') {
  // Implementar sistema de notificaciones visual
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.textContent = message;
  
  document.body.appendChild(notification);
  
  // Remover despuÃ©s de 5 segundos
  setTimeout(() => {
    notification.remove();
  }, 5000);
}

// Exportar configuraciÃ³n para uso en otros mÃ³dulos
export default {
  app,
  db,
  auth,
  storage,
  functions,
  collections,
  appConfig,
  getUserConfig,
  initializeApp
};
```

---

## ğŸ› ï¸ FUNCIONES UTILITARIAS ACTUALIZADAS

### 8. ğŸ”§ utils.js - Funciones de apoyo
```javascript
// utils.js - Funciones utilitarias actualizadas
import { collections } from './firebase-config.js';

// FunciÃ³n para generar IDs Ãºnicos
export function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

// FunciÃ³n para formatear fechas
export function formatDate(timestamp, format = 'short') {
  const date = new Date(timestamp);
  
  const options = {
    short: { 
      day: '2-digit', 
      month: '2-digit', 
      year: 'numeric' 
    },
    long: { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    },
    datetime: { 
      year: 'numeric', 
      month: '2-digit', 
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    }
  };
  
  return new Intl.DateTimeFormat('es-ES', options[format]).format(date);
}

// FunciÃ³n para validar datos de usuario
export function validateUserData(userData) {
  const errors = [];
  
  if (!userData.nombre || userData.nombre.trim().length < 2) {
    errors.push('El nombre debe tener al menos 2 caracteres');
  }
  
  if (!userData.apellido || userData.apellido.trim().length < 2) {
    errors.push('El apellido debe tener al menos 2 caracteres');
  }
  
  if (!userData.email || !isValidEmail(userData.email)) {
    errors.push('Email invÃ¡lido');
  }
  
  if (!userData.telefono || !isValidPhone(userData.telefono)) {
    errors.push('TelÃ©fono invÃ¡lido');
  }
  
  return {
    isValid: errors.length === 0,
    errors: errors
  };
}

// FunciÃ³n para validar email
export function isValidEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

// FunciÃ³n para validar telÃ©fono
export function isValidPhone(phone) {
  const phoneRegex = /^[\+]?[1-9][\d]{0,15}$/;
  return phoneRegex.test(phone.replace(/\s/g, ''));
}

// FunciÃ³n para limpiar texto
export function sanitizeText(text) {
  if (!text) return '';
  return text.toString().trim().replace(/[<>]/g, '');
}

// FunciÃ³n para calcular compatibilidad entre anfitriÃ³n y visitante
export function calculateCompatibility(host, visitor) {
  let score = 0;
  let maxScore = 0;
  
  // Verificar capacidad (peso: 40%)
  maxScore += 40;
  if (host.datos_hospedador?.personas_puede_hospedar >= visitor.datos_visitante?.numero_personas) {
    score += 40;
  } else {
    score += 20; // PuntuaciÃ³n parcial si estÃ¡ cerca
  }
  
  // Verificar cochera (peso: 20%)
  maxScore += 20;
  if (visitor.datos_visitante?.tiene_vehiculo) {
    if (host.datos_hospedador?.tiene_cochera) {
      score += 20;
    }
  } else {
    score += 20; // Si no tiene vehÃ­culo, no importa la cochera
  }
  
  // Verificar habitaciones (peso: 30%)
  maxScore += 30;
  if (host.datos_hospedador?.numero_habitaciones >= visitor.datos_visitante?.habitaciones_solicitadas) {
    score += 30;
  } else if (host.datos_hospedador?.numero_habitaciones > 0) {
    score += 15; // PuntuaciÃ³n parcial
  }
  
  // Verificar servicios adicionales (peso: 10%)
  maxScore += 10;
  if (host.datos_hospedador?.servicios_adicionales?.length > 0) {
    score += 10;
  }
  
  return Math.round((score / maxScore) * 100);
}

// FunciÃ³n para obtener color de compatibilidad
export function getCompatibilityColor(score) {
  if (score >= 80) return '#4CAF50'; // Verde
  if (score >= 60) return '#FF9800'; // Naranja
  if (score >= 40) return '#FFC107'; // Amarillo
  return '#F44336'; // Rojo
}

// FunciÃ³n para obtener el estado de verificaciÃ³n del usuario
export function getUserVerificationStatus(userData) {
  if (!userData?.verificacion) {
    return 'sin_verificar';
  }
  
  return userData.verificacion.estado || 'pendiente_verificacion';
}

// FunciÃ³n para obtener el badge de verificaciÃ³n
export function getVerificationBadge(status) {
  const badges = {
    'sin_verificar': { text: 'Sin verificar', class: 'badge-danger', icon: 'âŒ' },
    'pendiente_verificacion': { text: 'Pendiente', class: 'badge-warning', icon: 'â³' },
    'verificado': { text: 'Verificado', class: 'badge-success', icon: 'âœ…' },
    'rechazado': { text: 'Rechazado', class: 'badge-danger', icon: 'âŒ' }
  };
  
  return badges[status] || badges['sin_verificar'];
}

// FunciÃ³n para calcular valoraciÃ³n cristiana
export function calculateChristianRating(valoraciones) {
  if (!valoraciones || valoraciones.length === 0) {
    return { promedio: 2, total: 0 }; // Base: 2 estrellas (registro + verificaciÃ³n)
  }
  
  const totalPuntos = valoraciones.reduce((sum, val) => sum + val.puntos, 0);
  const promedio = Math.round((totalPuntos / valoraciones.length) * 10) / 10;
  
  return {
    promedio: promedio + 2, // Sumar las 2 estrellas base
    total: valoraciones.length
  };
}

// FunciÃ³n para generar estrellas visuales
export function generateStars(rating, maxStars = 5) {
  const fullStars = Math.floor(rating);
  const hasHalfStar = rating % 1 >= 0.5;
  const emptyStars = maxStars - fullStars - (hasHalfStar ? 1 : 0);
  
  return 'â­'.repeat(fullStars) + 
         (hasHalfStar ? 'â­' : '') + 
         'â˜†'.repeat(emptyStars);
}

// FunciÃ³n para obtener el estado de una postulaciÃ³n
export function getPostulationStatus(postulacion) {
  const estados = {
    'postulado': { text: 'Postulado', class: 'status-pending', icon: 'ğŸ“' },
    'verificado': { text: 'Verificado', class: 'status-verified', icon: 'âœ…' },
    'asignado': { text: 'Asignado', class: 'status-assigned', icon: 'ğŸ¤' },
    'rechazado': { text: 'Rechazado', class: 'status-rejected', icon: 'âŒ' },
    'cancelado': { text: 'Cancelado', class: 'status-cancelled', icon: 'ğŸš«' }
  };
  
  return estados[postulacion.estado] || estados['postulado'];
}

// FunciÃ³n para manejar errores de Firebase
export function handleFirebaseError(error) {
  console.error('Firebase Error:', error);
  
  const errorMessages = {
    'permission-denied': 'No tienes permisos para realizar esta acciÃ³n',
    'not-found': 'El documento solicitado no existe',
    'already-exists': 'El documento ya existe',
    'invalid-argument': 'Argumento invÃ¡lido proporcionado',
    'unauthenticated': 'Debes estar autenticado para realizar esta acciÃ³n',
    'unavailable': 'Servicio no disponible temporalmente',
    'network-request-failed': 'Error de conexiÃ³n. Verifica tu internet.'
  };
  
  const userMessage = errorMessages[error.code] || 'Error desconocido. Intenta de nuevo.';
  
  return {
    code: error.code,
    message: userMessage,
    originalMessage: error.message
  };
}

// FunciÃ³n para validar permisos de usuario
export function validateUserPermissions(user, action, resource = null) {
  if (!user || !user.rol) {
    return { allowed: false, reason: 'Usuario no autenticado' };
  }
  
  const userConfig = getUserConfig(user.rol);
  
  switch (action) {
    case 'create_event':
      return { 
        allowed: userConfig.canCreateEvents, 
        reason: userConfig.canCreateEvents ? null : 'No tienes permisos para crear eventos' 
      };
      
    case 'edit_event':
      if (user.rol === 'administrador') {
        return { allowed: true, reason: null };
      }
      
      if (user.rol === 'editor' && resource) {
        const canEdit = user.eventos_asignados?.includes(resource.id);
        return { 
          allowed: canEdit, 
          reason: canEdit ? null : 'No tienes permisos para editar este evento' 
        };
      }
      
      return { allowed: false, reason: 'No tienes permisos para editar eventos' };
      
    case 'verify_user':
      return { 
        allowed: userConfig.canVerifyUsers, 
        reason: userConfig.canVerifyUsers ? null : 'No tienes permisos para verificar usuarios' 
      };
      
    case 'manage_users':
      return { 
        allowed: userConfig.canManageUsers, 
        reason: userConfig.canManageUsers ? null : 'No tienes permisos para gestionar usuarios' 
      };
      
    default:
      return { allowed: false, reason: 'AcciÃ³n no reconocida' };
  }
}

// FunciÃ³n para generar cÃ³digo de respaldo
export function generateBackupCode() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  
  for (let i = 0; i < 8; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  
  return code;
}

// FunciÃ³n para detectar dispositivo mÃ³vil
export function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

// FunciÃ³n para copiar texto al portapapeles
export async function copyToClipboard(text) {
  try {
    await navigator.clipboard.write
